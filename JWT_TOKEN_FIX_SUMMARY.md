# JWT Token Authentication Fix

## Problem Identified

The backend was experiencing 422 (Unprocessable Entity) errors on the following endpoints:
- `GET /api/data`
- `GET /api/notifications/`
- `GET /api/messages/`
- `GET /api/notifications/unread-count`
- `GET /api/messages/unread-count`

### Root Cause

The issue was a **JWT token format mismatch**:

1. **Token Generation**: The backend was using a custom `generate_jwt_token()` function that manually created JWT tokens using the `jwt` library with only `sub` and `exp` claims.

2. **Token Validation**: The backend routes were using Flask-JWT-Extended's `@jwt_required()` decorator, which expects tokens generated by Flask-JWT-Extended's own `create_access_token()` function.

3. **Missing Claims**: Flask-JWT-Extended expects additional claims like:
   - `iat` (issued at)
   - `type` (token type - access/refresh)
   - `jti` (JWT ID - optional)

When Flask-JWT-Extended tried to validate the manually created tokens, it couldn't properly decode them, resulting in 422 errors instead of the typical 401 errors.

## Changes Made

### Backend Changes

#### 1. `backend/utils/auth_token.py`
**Before:**
```python
def generate_jwt_token(user_id):
    payload = {
        "sub": user_id,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")
```

**After:**
```python
from flask_jwt_extended import create_access_token

def generate_jwt_token(user_id):
    # Use Flask-JWT-Extended to create properly formatted tokens
    access_token = create_access_token(
        identity=user_id,
        expires_delta=datetime.timedelta(hours=24)
    )
    return access_token
```

#### 2. `backend/services/oauth_service.py`
Updated the `generate_jwt_token()` method to use Flask-JWT-Extended's `create_access_token()` instead of manually encoding tokens.

### Frontend Changes

#### `frontend/src/services/apiService.js`
Updated the axios error interceptor to handle both 401 and 422 status codes by clearing authentication data and redirecting to login:

```javascript
// Handle 401 errors (unauthorized) and 422 errors (malformed JWT token)
if (error.response?.status === 401 || error.response?.status === 422) {
  console.warn(`ðŸ” Authentication error (${error.response.status}). Clearing session...`);
  // Clear all authentication data
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  // ... clear other auth data
  window.location.href = '/login?message=session_expired';
}
```

## Testing & Next Steps

### For Users Currently Logged In

**IMPORTANT**: Existing tokens in localStorage are in the old format and will not work. Users need to:

1. **Clear Browser Data** (Choose ONE option):
   - **Option A**: Press `F12` â†’ Console â†’ Run:
     ```javascript
     localStorage.clear();
     location.reload();
     ```
   - **Option B**: Manually clear browser cache/cookies
   - **Option C**: Use Incognito/Private browsing mode

2. **Log Out and Log In Again**: 
   - This will generate a new token with the correct Flask-JWT-Extended format
   - The new token will work with all `@jwt_required()` endpoints

### Verification Steps

After logging in with the new token, verify that:

1. âœ… No 422 errors appear in the network tab
2. âœ… Dashboard data loads correctly
3. âœ… Notifications endpoint returns data (empty array if no notifications)
4. âœ… Messages endpoint returns data (empty array if no messages)
5. âœ… All protected routes work without authentication errors

### Quick Test

Open browser console and run:
```javascript
// Check if token exists
console.log('Token:', localStorage.getItem('token'));

// Test dashboard endpoint
fetch('http://localhost:3002/api/data', {
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
})
.then(r => r.json())
.then(d => console.log('Dashboard Data:', d))
.catch(e => console.error('Error:', e));
```

## Benefits of This Fix

1. âœ… **Proper Token Format**: Tokens now include all required Flask-JWT-Extended claims
2. âœ… **Better Error Handling**: Frontend automatically handles token format errors
3. âœ… **Consistency**: All token generation now uses the same Flask-JWT-Extended method
4. âœ… **Security**: Leverages Flask-JWT-Extended's built-in security features
5. âœ… **Maintainability**: Easier to maintain with standardized token generation

## Technical Details

### Flask-JWT-Extended Token Structure

Tokens generated by `create_access_token()` include:
```json
{
  "sub": "user_id_here",
  "iat": 1697803923,
  "exp": 1697890323,
  "type": "access",
  "jti": "unique-jwt-id",
  "fresh": false
}
```

### Token Expiration
- **Duration**: 24 hours (configurable in `backend/config.py`)
- **Automatic Refresh**: Not currently implemented (future enhancement)

## Future Enhancements

1. **Refresh Tokens**: Implement refresh token rotation for better security
2. **Token Blacklisting**: Add token revocation on logout
3. **Token Validation Middleware**: Add custom middleware for additional validation
4. **Error Logging**: Enhanced error logging for authentication failures

## Related Files

- `backend/utils/auth_token.py` - Token generation utility
- `backend/services/oauth_service.py` - OAuth token generation
- `backend/services/auth_service.py` - Authentication service using token generation
- `frontend/src/services/apiService.js` - API client with error handling
- `frontend/src/context/NotificationContext.jsx` - Uses notification/message APIs
- `backend/routes/dashboard_routes.py` - Dashboard data endpoint
- `backend/routes/notification_routes.py` - Notification endpoints
- `backend/routes/message_routes.py` - Message endpoints

## Questions?

If you continue to see 422 errors after following these steps:
1. Verify you've cleared localStorage and logged in again
2. Check the backend console for any JWT-related errors
3. Verify the backend restarted successfully with the new code
4. Check that `flask-jwt-extended` is installed: `pip list | grep flask-jwt-extended`

