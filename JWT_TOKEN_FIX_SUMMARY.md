# JWT Token Authentication Fix

## Problem Identified

The backend was experiencing 422 (Unprocessable Entity) errors on the following endpoints:
- `GET /api/data`
- `GET /api/notifications/`
- `GET /api/messages/`
- `GET /api/notifications/unread-count`
- `GET /api/messages/unread-count`

### Root Cause

The issue was a **JWT token format mismatch**:

1. **Token Generation**: The backend was using a custom `generate_jwt_token()` function that manually created JWT tokens using the `jwt` library with only `sub` and `exp` claims.

2. **Token Validation**: The backend routes were using Flask-JWT-Extended's `@jwt_required()` decorator, which expects tokens generated by Flask-JWT-Extended's own `create_access_token()` function.

3. **Missing Claims**: Flask-JWT-Extended expects additional claims like:
   - `iat` (issued at)
   - `type` (token type - access/refresh)
   - `jti` (JWT ID - optional)

When Flask-JWT-Extended tried to validate the manually created tokens, it couldn't properly decode them, resulting in 422 errors instead of the typical 401 errors.

## Changes Made

### Backend Changes

#### 1. `backend/utils/auth_token.py`
**Before:**
```python
def generate_jwt_token(user_id):
    payload = {
        "sub": user_id,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")
```

**After:**
```python
from flask_jwt_extended import create_access_token

def generate_jwt_token(user_id):
    # Use Flask-JWT-Extended to create properly formatted tokens
    access_token = create_access_token(
        identity=user_id,
        expires_delta=datetime.timedelta(hours=24)
    )
    return access_token
```

#### 2. `backend/services/oauth_service.py`
Updated the `generate_jwt_token()` method to use Flask-JWT-Extended's `create_access_token()` instead of manually encoding tokens.

### Frontend Changes

#### `frontend/src/services/apiService.js`
Updated the axios error interceptor to handle both 401 and 422 status codes by clearing authentication data and redirecting to login:

```javascript
// Handle 401 errors (unauthorized) and 422 errors (malformed JWT token)
if (error.response?.status === 401 || error.response?.status === 422) {
  console.warn(`🔐 Authentication error (${error.response.status}). Clearing session...`);
  // Clear all authentication data
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  // ... clear other auth data
  window.location.href = '/login?message=session_expired';
}
```

## Testing & Next Steps

### For Users Currently Logged In

**IMPORTANT**: Existing tokens in localStorage are in the old format and will not work. Users need to:

1. **Clear Browser Data** (Choose ONE option):
   - **Option A**: Press `F12` → Console → Run:
     ```javascript
     localStorage.clear();
     location.reload();
     ```
   - **Option B**: Manually clear browser cache/cookies
   - **Option C**: Use Incognito/Private browsing mode

2. **Log Out and Log In Again**: 
   - This will generate a new token with the correct Flask-JWT-Extended format
   - The new token will work with all `@jwt_required()` endpoints

### Verification Steps

After logging in with the new token, verify that:

1. ✅ No 422 errors appear in the network tab
2. ✅ Dashboard data loads correctly
3. ✅ Notifications endpoint returns data (empty array if no notifications)
4. ✅ Messages endpoint returns data (empty array if no messages)
5. ✅ All protected routes work without authentication errors

### Quick Test

Open browser console and run:
```javascript
// Check if token exists
console.log('Token:', localStorage.getItem('token'));

// Test dashboard endpoint
fetch('http://localhost:3002/api/data', {
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
})
.then(r => r.json())
.then(d => console.log('Dashboard Data:', d))
.catch(e => console.error('Error:', e));
```

## Benefits of This Fix

1. ✅ **Proper Token Format**: Tokens now include all required Flask-JWT-Extended claims
2. ✅ **Better Error Handling**: Frontend automatically handles token format errors
3. ✅ **Consistency**: All token generation now uses the same Flask-JWT-Extended method
4. ✅ **Security**: Leverages Flask-JWT-Extended's built-in security features
5. ✅ **Maintainability**: Easier to maintain with standardized token generation

## Technical Details

### Flask-JWT-Extended Token Structure

Tokens generated by `create_access_token()` include:
```json
{
  "sub": "user_id_here",
  "iat": 1697803923,
  "exp": 1697890323,
  "type": "access",
  "jti": "unique-jwt-id",
  "fresh": false
}
```

### Token Expiration
- **Duration**: 24 hours (configurable in `backend/config.py`)
- **Automatic Refresh**: Not currently implemented (future enhancement)

## Future Enhancements

1. **Refresh Tokens**: Implement refresh token rotation for better security
2. **Token Blacklisting**: Add token revocation on logout
3. **Token Validation Middleware**: Add custom middleware for additional validation
4. **Error Logging**: Enhanced error logging for authentication failures

## Related Files

- `backend/utils/auth_token.py` - Token generation utility
- `backend/services/oauth_service.py` - OAuth token generation
- `backend/services/auth_service.py` - Authentication service using token generation
- `frontend/src/services/apiService.js` - API client with error handling
- `frontend/src/context/NotificationContext.jsx` - Uses notification/message APIs
- `backend/routes/dashboard_routes.py` - Dashboard data endpoint
- `backend/routes/notification_routes.py` - Notification endpoints
- `backend/routes/message_routes.py` - Message endpoints

## Questions?

If you continue to see 422 errors after following these steps:
1. Verify you've cleared localStorage and logged in again
2. Check the backend console for any JWT-related errors
3. Verify the backend restarted successfully with the new code
4. Check that `flask-jwt-extended` is installed: `pip list | grep flask-jwt-extended`

